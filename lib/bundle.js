// Generated by CoffeeScript 1.10.0
(function() {
  var _, builtin, bundle, coffee, defaultOpts, dependsRecur, findPackageJson, fs, funclet, isExternal, jsYaml, loglet, parser, path, resolve, showDepends, topsort, transform;

  resolve = require('browser-resolve');

  loglet = require('loglet');

  path = require('path');

  fs = require('graceful-fs');

  funclet = require('funclet');

  parser = require('./parser');

  coffee = require('coffee-script');

  _ = require('underscore');

  builtin = require('./builtin');

  jsYaml = require('js-yaml');

  defaultOpts = {
    basedir: process.cwd(),
    extensions: ['.js', '.coffee']
  };

  isExternal = function(spec) {
    return spec.match(/^[^\.\/]/);
  };

  findPackageJson = function(filePath, cb) {
    var helper;
    helper = function(filePath, cb) {
      var packageJson;
      packageJson = path.join(filePath, 'package.json');
      return fs.stat(packageJson, function(err, stat) {
        var parentPath;
        if (err) {
          parentPath = path.dirname(filePath);
          if (parentPath === filePath) {
            return cb(err);
          } else {
            return helper(parentPath, cb);
          }
        } else if (stat.isFile()) {
          return fs.readFile(packageJson, 'utf8', function(err, data) {
            var e, error, parsed;
            if (err) {
              return cb(err);
            } else {
              try {
                parsed = JSON.parse(data);
                return cb(null, filePath, parsed);
              } catch (error) {
                e = error;
                return cb(e);
              }
            }
          });
        } else {
          parentPath = path.dirname(filePath);
          if (parentPath === filePath) {
            return cb({
              error: 'package.json.not.found'
            });
          } else {
            return helper(parentPath, cb);
          }
        }
      });
    };
    return helper(path.resolve(filePath), cb);
  };

  dependsRecur = function(spec, options, cb) {
    var compile, depends, detect, normalize, normalizeName, parse, sourceMap;
    if (arguments.length === 2) {
      cb = options;
      options = defaultOpts;
    } else {
      options = _.extend({}, defaultOpts, options);
    }
    options.rootdir || (options.rootdir = options.basedir);
    sourceMap = {};
    normalize = function(result) {
      var res;
      if (options.shims.hasOwnProperty(result.key)) {
        res = _.extend({}, result, options.shims[result.key]);
        return res;
      } else {
        return result;
      }
    };
    compile = function(filePath, data) {
      var e, error;
      try {
        switch (path.extname(filePath)) {
          case '.coffee':
            return parser.parse(coffee.compile(data));
          case '.js':
            return parser.parse(data);
          case '.json':
            return "module.exports = " + data + ";";
          case '.yml':
          case '.yaml':
            return "module.exports = " + JSON.stringify(jsYaml.safeLoad(data)) + ";";
          default:
            throw new Error("unknown_file_extension: " + (path.extname(filePath)) + " @ " + filePath);
        }
      } catch (error) {
        e = error;
        throw {
          error: 'compilation',
          filePath: filePath,
          inner: e
        };
      }
    };
    detect = function(filePath, content) {
      var required;
      required = _.filter(content, function(item) {
        return item instanceof Object && item.require;
      });
      return _.uniq(_.map(required, function(item) {
        if (item.global) {
          if (builtin.hasOwnProperty(item.global)) {
            return builtin[item.global];
          } else {
            throw {
              error: 'unknown_global',
              global: item.global
            };
          }
        } else {
          return item.require;
        }
      }));
    };
    normalizeName = function(key, relPath) {
      var result;
      result = key.replace(/[\/\.\-\\]/g, '_');
      return "_Module_" + result;
    };
    parse = function(filePath, key, relPath, cb) {
      var content;
      content = null;
      return funclet.bind(fs.readFile, filePath, 'utf8').then(function(data, next) {
        content = compile(filePath, data);
        return next(null, detect(filePath, content));
      })["catch"](cb).done(function(required) {
        var result;
        result = normalize({
          key: key,
          relPath: relPath,
          depends: required,
          filePath: filePath,
          name: normalizeName(key, relPath),
          content: content
        });
        return cb(null, result);
      });
    };
    depends = function(spec, options, cb) {
      var filePath, key, parent, relPath, result, tabLevel, tabMe;
      tabLevel = options.tabLevel || 0;
      tabMe = function() {
        var i;
        return ((function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = tabLevel; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push('  ');
          }
          return results;
        })()).join('');
      };
      parent = options.parent || null;
      if (sourceMap.hasOwnProperty(spec)) {
        return cb(null, sourceMap[spec]);
      }
      filePath = null;
      relPath = null;
      key = null;
      result = null;
      return funclet.start(function(next) {
        return resolve(spec, options, function(err, res) {
          return next(err, res);
        });
      }).then(function(val, next) {
        filePath = val;
        relPath = './' + path.relative(options.rootdir, filePath);
        key = isExternal(spec) ? spec : relPath;
        if (sourceMap.hasOwnProperty(key)) {
          return cb(null, sourceMap[key]);
        } else if (filePath === spec && isExternal(filePath)) {
          return next({
            error: 'core_module_unimplemented',
            module: spec,
            message: 'implement core module via browser field in package.json.'
          });
        } else if (filePath.match(/browser-resolve\/empty\.js$/)) {
          return next(null, normalize({
            key: spec,
            filePath: filePath,
            depends: [],
            skipped: true,
            name: normalizeName(spec, filePath)
          }));
        } else {
          return parse(filePath, key, relPath, next);
        }
      }).then(function(val, next) {
        result = val;
        sourceMap[result.key] = result;
        return next(null, result.depends);
      }).thenMap(function(childSpec, next) {
        var opts;
        opts = _.extend({}, options, {
          basedir: path.dirname(filePath),
          tabLevel: tabLevel + 1,
          parent: spec
        });
        return depends(childSpec, opts, function(err, mod) {
          if (err) {
            return next(err);
          } else {
            return next(null, {
              spec: childSpec,
              module: mod
            });
          }
        });
      })["catch"](cb).done(function(required) {
        result.depends = required;
        return cb(null, result);
      });
    };
    return funclet.start(function(next) {
      return findPackageJson(spec, next);
    })["catch"](function(err) {
      return cb(err);
    }).done(function(packagePath, data) {
      var ref;
      options.shims = _.extend({}, options.shims || {}, ((ref = data.bundlet) != null ? ref.shims : void 0) || {});
      options.modules = builtin;
      return depends(spec, options, cb);
    });
  };

  topsort = function(mod) {
    var helper, included, recurs, result;
    included = {};
    result = [];
    recurs = {};
    helper = function(mod) {
      var i, j, len, module, ref, ref1, spec;
      if (recurs.hasOwnProperty(mod.key)) {
        console.error("topsort:circular_topology", mod.key);
        return;
      }
      recurs[mod.key] = mod;
      ref = mod.depends;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        ref1 = ref[i], spec = ref1.spec, module = ref1.module;
        if (!included.hasOwnProperty(module.key)) {
          helper(module);
        }
      }
      included[mod.key] = mod;
      return result.push(mod);
    };
    helper(mod);
    return result;
  };

  transform = function(mod) {
    var buffer, content, i, item, j, len, mapped, ref;
    if (mod.external) {
      return "// module: " + mod.key + " \nvar " + mod.name + " = " + mod.external + ";";
    } else if (mod.content) {
      buffer = [];
      ref = mod.content;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (typeof item === 'string') {
          buffer.push(item);
        } else if (item.global) {
          buffer.push(item.global);
        } else if (item.require) {
          mapped = _.find(mod.depends, function(dep) {
            return dep.spec === item.require;
          });
          if (mapped) {
            buffer.push(mapped.module.name);
          } else {
            throw {
              error: 'unknown_mapped_spec',
              key: mod.key,
              relPath: mod.relPath,
              spec: item.require,
              depends: mod.depends
            };
          }
        } else if (item.comment) {
          buffer.push(item.comment);
        } else {
          throw {
            error: 'unknown_parsed_object',
            object: item
          };
        }
      }
      content = buffer.join('');
      return "// module: " + mod.key + "\nvar " + mod.name + " = (function() {\n  var exports = {};\n  var module = { exports: exports };\n  (function (){\n    " + content + "\n  })();\n  return " + (mod.exports ? mod.exports : 'module.exports') + ";\n})();";
    } else {
      throw {
        error: 'invalid_module_structure',
        module: mod
      };
    }
  };

  showDepends = function(mods) {
    var item, j, len, mod;
    loglet.log('------- MODULE DEPENDENCY ------------');
    for (j = 0, len = mods.length; j < len; j++) {
      mod = mods[j];
      item = {
        key: mod.key,
        name: mod.name,
        relPath: mod.relPath,
        depends: mod.depends,
        exports: mod.exports,
        external: mod.external
      };
      loglet.log('----------------------------------------');
      loglet.log(item);
    }
    return loglet.log('------- END MODULE DEPENDENCY ------------');
  };

  bundle = function(spec, options, cb) {
    if (arguments.length === 2) {
      cb = options;
      options = {};
    }
    return dependsRecur(spec, function(err, res) {
      var e, error, mod, sorted;
      if (err) {
        return cb(err);
      } else {
        try {
          sorted = topsort(res);
          if (options.depends) {
            showDepends(sorted);
          }
          return cb(null, (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = sorted.length; j < len; j++) {
              mod = sorted[j];
              results.push(transform(mod));
            }
            return results;
          })());
        } catch (error) {
          e = error;
          return cb(e);
        }
      }
    });
  };

  module.exports = {
    bundle: bundle
  };

}).call(this);
